% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mapresponse.R
\name{coldata.to.imagemat}
\alias{coldata.to.imagemat}
\title{These functions create maps of response variables using the R funct...}
\usage{
coldata.to.imagemat(z, x = NULL, y = NULL, gridsize = 20, plotmin = c(0,
  0), plotmax = c(1000, 500))
}
\arguments{
\item{z}{A numeric vector of responses, which means an attribute which has map coordinates.}

\item{x}{The map coordinates of each column in the matrix, and the values with which the x-axis of the map will be numbered.

The number of columns of z, dim(z)[2], must be exactly length(x). If x is NULL, then it is calculated using plotmax.}

\item{y}{The map coordinates of each row in the matrix, and the values with which the y-axis of the map will be numbered;
dim(z)[1] must be exactly length(y). If y is NULL, then it is calculated using plotmax.}

\item{gridsize}{Size of quadrats into which the map is divided; must be square quadrats. This cannot be NULL.}

\item{plotmin}{The minimum plot x and y coordinates; in CTFS plots, these are always 0,0. Ignored if x and y are submitted.}

\item{plotmax}{Maximum plot x and y coordinates. The default, 1000,500, is typical CTFS 50-ha plot. Ignored if x and y are submitted.}
}
\description{
These functions create maps of response variables using the R functions
contour, image, and filled.contour. Those functions are powerful and do the
difficult work, but they are a bit tricky to learn and have many options. If
you are expert with those 3 R functions, the functions below will not be
especially useful. They simply rearrange various types of data into the
correct format.

The first, coldata.to.imagemat, converts a vector of response variables and
converts it into a matrix of the correct form for use by contour, image, and
filled.contour. There must be one value of the response z for every position
in a grid overlain on the map. In the case of CTFS Plots, this means a value
for z at every quadrat, though quadrat can be any size.  The function
abundanceperquad (abundance.r) produces exactly the correct kind of vector
for use by coldata.to.imagemat. The function gxgy.to.index (quadfunc.r)
produces quadrat numbers that are the correct vector for use by
coldata.to.imagemat.

For example, consider a 50 ha plot of 1000 x 500 meters. If gridsize=20, the
standard quadrat, then there are 50 columns x 25 rows in the plot.

In that case, the length of vector z must be exactly 1250, length(x) must be
exactly 50, and length(y) exactly 25. Alternatively, x and y can be set

NULL and it will be calculated from plotmax=c(1000,500) and plotmin=c(0,0).
The simplest application of this function for CTFS plots is to set x and y
NULL, and plotmax to the correct plot dimensions. Then make sure z is the
right size for the number of quadrats.

The common error with image and contour maps is getting the proper dimensions
for z and the proper sizes for plotmax, x, and y. If you get an error data
length is not a sub-multiple or multiple of the number of rows'then one of
those inputs is wrong.

Return value is a list designed to match exactly the format of the RGDAL
raster object. It has components:
\itemize{
\item x: same as the argument x; if x is submitted as NULL, this is the vector
calculated by using plotmax;
\item y: likewise for y;
\item z: exactly as submitted;
\item columns: number of columns in the grid, same as length(x);
\item rows: Number of rows in the grid, same as length(y);
\item mat: The matrix needed for graphing, exactly as needed for instance by
imageGraph().
}
}
\examples{
\dontrun{

CTFSplot('bci',6,'full')

BA=abundanceperquad(bci.full6,gridsize=20,plotdim=c(1000,500),type='ba')
totalBAperquad=colSums(BA$ba)
summary(totalBAperquad)
matrixdata <- coldata.to.imagemat(
  z = totalBAperquad,
  x = NULL,
  y = NULL,
  gridsize = 20,
  plotmax = c(1000, 500)
)
length(totalBAperquad)
dim(matrixdata$mat)
length(matrixdata$x)
}

}
